#!/usr/bin/env python
from __future__ import absolute_import
import asyncore
from datetime import datetime
from smtpd import SMTPServer
from email import message_from_string
from .sacfs_flexcode import CODES

__all__ = [
	'CFSPDWScraper',
]
class CFSRTLScraper(object):
	 def __init__(self, update_frequency=None):
		# Update frequency is not relevant
		self.feed_handler = None
	 def process_message(self):
		time = timez.now().strftime('%H:%M:%S')
 		multimon_ng = subprocess.Popen("rtl_fm -o 4 -A lut -s 22050 -f 148.8125M - | multimon-ng -t raw -a FLEX -f alpha /dev/stdin", 
		stdout=subprocess.PIPE,
		stderr=subprocess.PIPE, 
		shell=True)
		while True:
		 	try:
                		nextline = multimon_ng.stdout.readline()
  				if "Failed" in multimon_ng.stderr.readline():
  					print "usb is in use or has not closed properly"
		  			print "looking for any process using rtl_fm"
                		else:
   					if not nextline: 
		    				pass 
   					else: 
    						try: 
     							flex, mdate, mtime, bitrate, other, capcode, o2, msg = nextline.split(" ", 7) 
    				except ValueError: 
     					print "invalid line", nextline 
    				else:
     					capcode = str(capcode)
     					flexcode = capcode.replace("]", " ")
     					flexcode = flexcode.replace("[", " ")
     					flexcode = int(flexcode)
     					if flexcode not in  filters:
      						flexcode = capcode
     					else: 
      						flexcode = str(filters[flexcode])    
    					puts(" [", newline=False)
    					puts(colored.green(mdate + " " + time), newline=False)
    					puts("] ", newline=False)
					print other + " " + bitrate
    					if "CFSRES" in msg:
    						 puts(colored.red(msg + " "), newline=False)
     					else:
       						puts(msg + " ", newline=False)
     					puts(colored.yellow(flexcode))
  					multimon_ng.poll() 
		  	sys.stdout.flush()
    
	def handler(self, **kwargs):
		self.feed_handler(**kwargs)

	def update(self, feed_handler):
		"""
		Pings feed for new events.
		"""
		self.feed_handler = feed_handler

	def update_forever(self, feed_handler):
		self.update(feed_handler)
		asyncore.loop()
